<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Redis | Gavy&#39;s TechBlog</title>
<link rel="shortcut icon" href="https://gavinzjzhang.github.io//favicon.ico?v=1603597478056">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://gavinzjzhang.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Redis | Gavy&#39;s TechBlog - Atom Feed" href="https://gavinzjzhang.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="👉摘要：Nosql概述、Redis入门、五大数据类型、三种特殊数据类型
🍌

微博案例
在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实..." />
    <meta name="keywords" content="中间件" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://gavinzjzhang.github.io/">
  <img class="avatar" src="https://gavinzjzhang.github.io//images/avatar.png?v=1603597478056" alt="">
  </a>
  <h1 class="site-title">
    Gavy&#39;s TechBlog
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          架构
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Redis
            </h2>
            <div class="post-info">
              <span>
                2020-10-14
              </span>
              <span>
                22 min read
              </span>
              
                <a href="https://gavinzjzhang.github.io/tag/UDikJXfkF/" class="post-tag">
                  # 中间件
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://gavinzjzhang.github.io//post-images/redis.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>👉摘要：Nosql概述、Redis入门、五大数据类型、三种特殊数据类型<br>
🍌</p>
<blockquote>
<p>微博案例<br>
在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。<br>
... ...</p>
</blockquote>
<!-- more -->
<h1 id="redis"><a href="">Redis</a></h1>
<h2 id="g-聊-redis">G-聊 Redis</h2>
<h2 id="nosql概述">Nosql概述</h2>
<h2 id="redis入门">Redis入门</h2>
<h2 id="五大数据类型">五大数据类型</h2>
<p><strong>感谢博客园<a href="https://home.cnblogs.com/u/xiaoxi/">平凡希</a></strong>：<a href="https://www.cnblogs.com/xiaoxi/p/7007695.html">redis学习（八）——redis应用场景</a>、</p>
<p><code>String字符串类型</code>  <code>List列表</code>  <code>Set集合</code>  <code>Hash哈希</code>  <code>ZSet有序集合</code></p>
<hr>
<h3 id="string-字符串">String (字符串)</h3>
<h5 id="常用命令">常用命令</h5>
<p>set、get、incr、decr、mget等。</p>
<pre><code class="language-bash">#set   get   
#字符串范围
127.0.0.1:6379&gt; set key1 &quot;hello,gavy&quot; #
OK
127.0.0.1:6379&gt; get key1
&quot;hello,gavy&quot;
127.0.0.1:6379&gt; getrange
(error) ERR wrong number of arguments for 'getrange' command
127.0.0.1:6379&gt; GETRANGE key1 0 3
&quot;hell&quot;
127.0.0.1:6379&gt; GETRANGE key1 0 -1
&quot;hello,gavy&quot;
127.0.0.1:6379&gt; 
################################################################

127.0.0.1:6379&gt; set
(error) ERR wrong number of arguments for 'set' command
127.0.0.1:6379&gt; set key1 &quot;hello,gavy&quot;
OK
127.0.0.1:6379&gt; get key1
&quot;hello,gavy&quot;
127.0.0.1:6379&gt; getrange
(error) ERR wrong number of arguments for 'getrange' command
127.0.0.1:6379&gt; GETRANGE key1 0 3
&quot;hell&quot;
127.0.0.1:6379&gt; GETRANGE key1 0 -1
&quot;hello,gavy&quot;
127.0.0.1:6379&gt; 



</code></pre>
<h5 id="应用场景">应用场景</h5>
<blockquote>
<p>计数</p>
</blockquote>
<p>微博数, 粉丝数</p>
<hr>
<h3 id="list-列表">List (列表)</h3>
<h5 id="常用命令-2">常用命令</h5>
<p>lpush,rpush,lpop,rpop,lrange等</p>
<h5 id="应用场景-2">应用场景</h5>
<p>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。</p>
<p>List 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用List结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，<br>
可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。</p>
<h5 id="实现方式">实现方式</h5>
<p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
<p>Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样<mark>List既可以作为栈，也可以作为队列</mark>。</p>
<h5 id="使用场景">使用场景</h5>
<blockquote>
<p>消息队列系统</p>
</blockquote>
<p>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。</p>
<p>比如：将Redis用作日志收集器</p>
<p>实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。</p>
<blockquote>
<p>取最新N个数据的操作</p>
</blockquote>
<p>记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。</p>
<pre><code class="language-java">//把当前登录人添加到链表里
ret = r.lpush(&quot;login:last_login_times&quot;, uid)

//保持链表只有N位
ret = redis.ltrim(&quot;login:last_login_times&quot;, 0, N-1)

//获得前N个最新登陆的用户Id列表
last_login_list = r.lrange(&quot;login:last_login_times&quot;, 0, N-1)
</code></pre>
<blockquote>
<p>sina微博案例</p>
</blockquote>
<p>在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。</p>
<p>我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。</p>
<hr>
<h3 id="set-集合">Set (集合)</h3>
<h5 id="常用命令-3">常用命令</h5>
<p>sadd,spop,smembers,sunion 等</p>
<h5 id="应用场景-3">应用场景</h5>
<p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Set数据结构，可以存储一些集合性的数据。</p>
<h5 id="实现方式-2">实现方式</h5>
<p>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p>
<h5 id="使用场景-2">使用场景</h5>
<blockquote>
<p>微博案例</p>
</blockquote>
<p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p>
<p><mark>Set是集合，是String类型的无序集合</mark>，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，<mark>set中的元素是没有顺序的</mark>。</p>
<blockquote>
<p>交集，并集，差集：(Set)</p>
</blockquote>
<pre><code class="language-java">//book表存储book名称

set book:1:name    ”The Ruby Programming Language”

set book:2:name     ”Ruby on rail”

set book:3:name     ”Programming Erlang”

//tag表使用集合来存储数据，因为集合擅长求交集、并集

sadd tag:ruby 1

sadd tag:ruby 2

sadd tag:web 2

sadd tag:erlang 3

//即属于ruby又属于web的书？

 inter_list = redis.sinter(&quot;tag.web&quot;, &quot;tag:ruby&quot;) 

//即属于ruby，但不属于web的书？

 inter_list = redis.sdiff(&quot;tag.ruby&quot;, &quot;tag:web&quot;) 

//属于ruby和属于web的书的合集？

 inter_list = redis.sunion(&quot;tag.ruby&quot;, &quot;tag:web&quot;)
</code></pre>
<blockquote>
<p>获取某段时间所有数据去重值</p>
</blockquote>
<p>这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。</p>
<hr>
<h3 id="hash-哈希">Hash (哈希)</h3>
<h5 id="常用命令-4">常用命令</h5>
<p>hget,hset,hgetall 等</p>
<pre><code class="language-bash">127.0.0.1:6379&gt; keys *
(empty array)
127.0.0.1:6379&gt; HSET myhash field3 5
(integer) 1
127.0.0.1:6379&gt; HSET myhash field3 6
(integer) 0
127.0.0.1:6379&gt; HGET myhash field3
&quot;6&quot;
127.0.0.1:6379&gt; HSET myhash field4 7 field5 8
(integer) 2
127.0.0.1:6379&gt; keys *
1) &quot;myhash&quot;
127.0.0.1:6379&gt; HKEYS *
(empty array)
127.0.0.1:6379&gt; HKEYS myhash
1) &quot;field3&quot;
2) &quot;field4&quot;
3) &quot;field5&quot;
127.0.0.1:6379&gt; HGET field4
(error) ERR wrong number of arguments for 'hget' command
127.0.0.1:6379&gt; HGET myhash field4
&quot;7&quot;
127.0.0.1:6379&gt; 
[root@ecs-kc1-small-1-linux-20200604230717 bin]# 
</code></pre>
<h5 id="应用场景-4">应用场景</h5>
<p>我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p>
<figure data-type="image" tabindex="1"><img src="https://gavinzjzhang.github.io//post-images/1603517535769.jpg" alt="" loading="lazy"></figure>
<p>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，<font color="#FF0000">增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题</font>。</p>
<figure data-type="image" tabindex="2"><img src="https://gavinzjzhang.github.io//post-images/1603517550430.jpg" alt="" loading="lazy"></figure>
<p>第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，<mark>虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的</mark>。</p>
<p>那么Redis提供的Hash很好的解决了这个问题，<mark>Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口</mark>，如下图：</p>
<figure data-type="image" tabindex="3"><img src="https://gavinzjzhang.github.io//post-images/1603517558571.jpg" alt="" loading="lazy"></figure>
<p>也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是<mark>通过</mark> <mark>key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</mark>。很好的解决了问题。</p>
<p>这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据，但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。</p>
<h5 id="实现方式-3">实现方式</h5>
<p>上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，<mark>这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap，此时encoding为ht</mark>。</p>
<h5 id="使用场景-3">使用场景</h5>
<blockquote>
<p>存储部分变更数据</p>
</blockquote>
<p>如用户信息等</p>
<hr>
<h3 id="zset-有序集合">ZSet (有序集合)</h3>
<h5 id="常用命令-5">常用命令</h5>
<p>zadd,zrange,zrem,zcard等</p>
<pre><code class="language-bash">127.0.0.1:6379&gt; keys *
(empty array)
127.0.0.1:6379&gt; HSET myhash field3 5
(integer) 1
127.0.0.1:6379&gt; HSET myhash field3 6
(integer) 0
127.0.0.1:6379&gt; HGET myhash field3
&quot;6&quot;
127.0.0.1:6379&gt; HSET myhash field4 7 field5 8
(integer) 2
127.0.0.1:6379&gt; keys *
1) &quot;myhash&quot;
127.0.0.1:6379&gt; HKEYS *
(empty array)
127.0.0.1:6379&gt; HKEYS myhash
1) &quot;field3&quot;
2) &quot;field4&quot;
3) &quot;field5&quot;
127.0.0.1:6379&gt; HGET field4
(error) ERR wrong number of arguments for 'hget' command
127.0.0.1:6379&gt; HGET myhash field4
&quot;7&quot;
127.0.0.1:6379&gt; 
[root@ecs-kc1-small-1-linux-20200604230717 bin]# 
</code></pre>
<h5 id="应用场景-5">应用场景</h5>
<p>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，<mark>而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序</mark>，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p>
<p>和Set相比，<mark>Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列</mark>，比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
<h5 id="实现方式-4">实现方式</h5>
<p>Redis sorted set的<mark>内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序</mark>，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<h5 id="使用场景-4">使用场景</h5>
<blockquote>
<p>set 排序</p>
</blockquote>
<p>存储班级成绩表、工资表排序</p>
<blockquote>
<p>带权重进行判断</p>
</blockquote>
<p>[普通消息,1]、[重要消息,2]</p>
<blockquote>
<p>排行榜</p>
</blockquote>
<p>取Top N</p>
<h3 id="redis实际应用场景"><strong>Redis实际应用场景</strong></h3>
<h4 id="1-显示最新的项目列表"><strong>1、显示最新的项目列表</strong></h4>
<p>下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。</p>
<pre><code class="language-CQL">SELECT * FROM foo WHERE ... ORDER BY time DESC LIMIT 10   
</code></pre>
<p>在Web应用中，“列出最新的回复”之类的查询非常普遍，这通常会带来可扩展性问题。这令人沮丧，因为项目本来就是按这个顺序被创建的，但要输出这个顺序却不得不进行排序操作。类似的问题就可以用Redis来解决。比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。我们假设数据库中的每条评论都有一个唯一的递增的ID字段。我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表：</p>
<pre><code>LPUSH latest.comments &lt;ID&gt;   
</code></pre>
<p>我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论：</p>
<pre><code>LTRIM latest.comments 0 5000 
</code></pre>
<p>每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成（使用伪代码）：</p>
<pre><code class="language-java">FUNCTION get_latest_comments(start, num_items):  
    id_list = redis.lrange(&quot;latest.comments&quot;,start,start+num_items - 1)  
    IF id_list.length &lt; num_items  
        id_list = SQL_DB(&quot;SELECT ... ORDER BY time LIMIT ...&quot;)  
    END  
    RETURN id_list  
END 
</code></pre>
<p>​    这里我们做的很简单。在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。</p>
<p>​    我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。</p>
<h4 id="2-排行榜应用取top-n操作"><strong>2、排行榜应用，取TOP N操作</strong></h4>
<p>这个需求与上面需求的不同之处在于，取最新N个数据的操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。</p>
<p>热门，排行榜应用：</p>
<pre><code class="language-java">//将登录次数和用户统一存储在一个sorted set里
zadd login:login_times 5 1
zadd login:login_times 1 2
zadd login:login_times 2 3
//当用户登录时，对该用户的登录次数自增1
ret = r.zincrby(&quot;login:login_times&quot;, 1, uid)
//那么如何获得登录次数最多的用户呢，逆序排列取得排名前N的用户
ret = r.zrevrange(&quot;login:login_times&quot;, 0, N-1)
</code></pre>
<p>另一个很普遍的需求是各种数据库的数据并非存储在内存中，因此在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。典型的比如那些在线游戏的排行榜，比如一个Facebook的游戏，根据得分你通常想要：</p>
<p>- 列出前100名高分选手</p>
<p>- 列出某用户当前的全球排名</p>
<p>这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。模式是这样的，每次获得新得分时，我们用这样的代码：</p>
<pre><code class="language-bash">ZADD leaderboard  &lt;score&gt;  &lt;username&gt;
</code></pre>
<p>你可能用userID来取代username，这取决于你是怎么设计的。得到前100名高分用户很简单：</p>
<pre><code>ZREVRANGE leaderboard 0 99
</code></pre>
<p>用户的全球排名也相似，只需要：</p>
<pre><code>ZRANK leaderboard &lt;username&gt;
</code></pre>
<h4 id="3-删除与过滤"><strong>3、删除与过滤</strong></h4>
<p>我们可以使用LREM来删除评论。如果删除操作非常少，另一个选择是直接跳过评论条目的入口，报告说该评论已经不存在。 有些时候你想要给不同的列表附加上不同的过滤器。如果过滤器的数量受到限制，你可以简单的为每个不同的过滤器使用不同的Redis列表。毕竟每个列表只有5000条项目，但Redis却能够使用非常少的内存来处理几百万条项目。</p>
<h4 id="4-按照用户投票和时间排序"><strong>4、按照用户投票和时间排序</strong></h4>
<p>排行榜的一种常见变体模式就像Reddit或Hacker News用的那样，新闻按照类似下面的公式根据得分来排序：score = points / time^alpha 因此用户的投票会相应的把新闻挖出来，但时间会按照一定的指数将新闻埋下去。下面是我们的模式，当然算法由你决定。模式是这样的，开始时先观察那些可能是最新的项目，例如首页上的1000条新闻都是候选者，因此我们先忽视掉其他的，这实现起来很简单。每次新的新闻贴上来后，我们将ID添加到列表中，使用LPUSH + LTRIM，确保只取出最新的1000条项目。有一项后台任务获取这个列表，并且持续的计算这1000条新闻中每条新闻的最终得分。计算结果由ZADD命令按照新的顺序填充生成列表，老新闻则被清除。这里的关键思路是排序工作是由后台任务来完成的。</p>
<h4 id="5-处理过期项目"><strong>5、处理过期项目</strong></h4>
<p>另一种常用的项目排序是按照时间排序。我们使用unix时间作为得分即可。 模式如下：</p>
<p>- 每次有新项目添加到我们的非Redis数据库时，我们把它加入到排序集合中。这时我们用的是时间属性，current_time和time_to_live。</p>
<p>- 另一项后台任务使用ZRANGE…SCORES查询排序集合，取出最新的10个项目。如果发现unix时间已经过期，则在数据库中删除条目。</p>
<h4 id="6-计数"><strong>6、计数</strong></h4>
<p>Redis是一个很好的计数器，这要感谢INCRBY和其他相似命令。我相信你曾许多次想要给数据库加上新的计数器，用来获取统计或显示新信息，但是最后却由于写入敏感而不得不放弃它们。好了，现在使用Redis就不需要再担心了。有了原子递增（atomic increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。例如这样操作：</p>
<pre><code>INCR user:&lt;id&gt; EXPIRE  
</code></pre>
<p>你可以计算出最近用户在页面间停顿不超过60秒的页面浏览量，当计数达到比如20时，就可以显示出某些条幅提示，或是其它你想显示的东西。</p>
<h4 id="7-特定时间内的特定项目"><strong>7、特定时间内的特定项目</strong></h4>
<p>​    另一项对于其他数据库很难，但Redis做起来却轻而易举的事就是统计在某段特点时间里有多少特定用户访问了某个特定资源。比如我想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。每次我获得一次新的页面浏览时我只需要这样做：</p>
<pre><code>SADD page:day1:&lt;page_id&gt; &lt;user_id&gt; 
</code></pre>
<p>当然你可能想用unix时间替换day1，比如time()-(time()%3600*24)等等。 想知道特定用户的数量吗？只需要使用</p>
<pre><code>SCARD page:day1:&lt;page_id&gt;
</code></pre>
<p>需要测试某个特定用户是否访问了这个页面？</p>
<pre><code>SISMEMBER page:day1:&lt;page_id&gt;
</code></pre>
<h4 id="8-查找某个值所在的区间区间无重合-sorted-set"><strong>8、查找某个值所在的区间(区间无重合) ：(Sorted Set)</strong></h4>
<p>例如有下面两个范围，10－20和30－40</p>
<ul>
<li>A_start 10, A_end 20</li>
<li>B_start 30, B_end 40</li>
</ul>
<p>我们将这两个范围的起始位置存在Redis的Sorted Sets数据结构中，基本范围起始值作为score，范围名加start和end为其value值：</p>
<pre><code class="language-bash">redis 127.0.0.1:6379&gt; zadd ranges 10 A_start
(integer) 1
redis 127.0.0.1:6379&gt; zadd ranges 20 A_end
(integer) 1
redis 127.0.0.1:6379&gt; zadd ranges 30 B_start
(integer) 1
redis 127.0.0.1:6379&gt; zadd ranges 40 B_end
(integer) 1
</code></pre>
<p>这样数据在插入Sorted Sets后，相当于是将这些起始位置按顺序排列好了。现在我需要查找15这个值在哪一个范围中，只需要进行如下的zrangbyscore查找：</p>
<pre><code class="language-bash">redis 127.0.0.1:6379&gt; zrangebyscore ranges (15 +inf LIMIT 0 1
1) &quot;A_end&quot;
</code></pre>
<p>这个命令的意思是在Sorted Sets中查找大于15的第一个值。（+inf在Redis中表示正无穷大，15前面的括号表示&gt;15而非&gt;=15）查找的结果是A_end，由于所有值是按顺序排列的，所以可以判定15是在A_start到A_end区间上，也就是说15是在A这个范围里。至此大功告成。</p>
<h4 id="9-交集并集差集set"><strong>9、交集，并集，差集：(Set)</strong></h4>
<pre><code class="language-java">//book表存储book名称
set book:1:name    ”The Ruby Programming Language”
set book:2:name     ”Ruby on rail”
set book:3:name     ”Programming Erlang”

//tag表使用集合来存储数据，因为集合擅长求交集、并集
sadd tag:ruby 1
sadd tag:ruby 2
sadd tag:web 2
sadd tag:erlang 3

//即属于ruby又属于web的书？
 inter_list = redis.sinter(&quot;tag.web&quot;, &quot;tag:ruby&quot;) 
//即属于ruby，但不属于web的书？
 inter_list = redis.sdiff(&quot;tag.ruby&quot;, &quot;tag:web&quot;) 
//属于ruby和属于web的书的合集？
 inter_list = redis.sunion(&quot;tag.ruby&quot;, &quot;tag:web&quot;)
</code></pre>
<h2 id="三种特殊数据类型">三种特殊数据类型</h2>
<hr>
<h3 id="geospatial-地理位置">geospatial 地理位置</h3>
<blockquote>
<p>georadius</p>
</blockquote>
<hr>
<h3 id="hyperloglog">hyperloglog</h3>
<hr>
<h3 id="bitmaps">bitmaps</h3>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#redis">Redis</a>
<ul>
<li><a href="#g-%E8%81%8A-redis">G-聊 Redis</a></li>
<li><a href="#nosql%E6%A6%82%E8%BF%B0">Nosql概述</a></li>
<li><a href="#redis%E5%85%A5%E9%97%A8">Redis入门</a></li>
<li><a href="#%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">五大数据类型</a>
<ul>
<li><a href="#string-%E5%AD%97%E7%AC%A6%E4%B8%B2">String (字符串)</a><br>
*
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
</ul>
</li>
<li><a href="#list-%E5%88%97%E8%A1%A8">List (列表)</a><br>
*
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2">常用命令</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2">应用场景</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li>
</ul>
</li>
<li><a href="#set-%E9%9B%86%E5%90%88">Set (集合)</a><br>
*
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3">常用命令</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3">应用场景</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-2">实现方式</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2">使用场景</a></li>
</ul>
</li>
<li><a href="#hash-%E5%93%88%E5%B8%8C">Hash (哈希)</a><br>
*
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4">常用命令</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4">应用场景</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-3">实现方式</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3">使用场景</a></li>
</ul>
</li>
<li><a href="#zset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">ZSet (有序集合)</a><br>
*
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5">常用命令</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5">应用场景</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-4">实现方式</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4">使用场景</a></li>
</ul>
</li>
<li><a href="#redis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>Redis实际应用场景</strong></a>
<ul>
<li><a href="#1-%E6%98%BE%E7%A4%BA%E6%9C%80%E6%96%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8"><strong>1、显示最新的项目列表</strong></a></li>
<li><a href="#2-%E6%8E%92%E8%A1%8C%E6%A6%9C%E5%BA%94%E7%94%A8%E5%8F%96top-n%E6%93%8D%E4%BD%9C"><strong>2、排行榜应用，取TOP N操作</strong></a></li>
<li><a href="#3-%E5%88%A0%E9%99%A4%E4%B8%8E%E8%BF%87%E6%BB%A4"><strong>3、删除与过滤</strong></a></li>
<li><a href="#4-%E6%8C%89%E7%85%A7%E7%94%A8%E6%88%B7%E6%8A%95%E7%A5%A8%E5%92%8C%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F"><strong>4、按照用户投票和时间排序</strong></a></li>
<li><a href="#5-%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E9%A1%B9%E7%9B%AE"><strong>5、处理过期项目</strong></a></li>
<li><a href="#6-%E8%AE%A1%E6%95%B0"><strong>6、计数</strong></a></li>
<li><a href="#7-%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E7%9A%84%E7%89%B9%E5%AE%9A%E9%A1%B9%E7%9B%AE"><strong>7、特定时间内的特定项目</strong></a></li>
<li><a href="#8-%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%80%BC%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%BA%E9%97%B4%E5%8C%BA%E9%97%B4%E6%97%A0%E9%87%8D%E5%90%88-sorted-set"><strong>8、查找某个值所在的区间(区间无重合) ：(Sorted Set)</strong></a></li>
<li><a href="#9-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E9%9B%86set"><strong>9、交集，并集，差集：(Set)</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">三种特殊数据类型</a>
<ul>
<li><a href="#geospatial-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE">geospatial 地理位置</a></li>
<li><a href="#hyperloglog">hyperloglog</a></li>
<li><a href="#bitmaps">bitmaps</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://gavinzjzhang.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://gavinzjzhang.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
